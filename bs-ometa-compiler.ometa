let Locals = ometa {
  trans = [:t ?(t == #name) :n ]                                  -> [t, this._renameVariable(n)]
        | [:t ?(t == #get) :n ]                                   -> [t, this._renameVariable(n)]
        | [:t (&anything:e ( ?(typeof e != "string" &&
                               e.length != undefined &&
                               e.length > 0) trans
                             | anything ))*:ts ]                  -> [t].concat(ts),

  rename = [ :allowed { this._allowed = allowed; } trans:result ] ->  result

};
Locals._renameVariable = function(name) {
  if (name != '$elf' && this._allowed[name])
    return '$vars.' + name;
  return name;
};

let BSSemActionParser = ometa(BSJSParser) {
  curlySemAction = "{" expr:r sc "}"          -> r
                 | "{" (srcElem:s &srcElem -> s)*:ss
                   ( expr:r sc -> [#return, r] | srcElem):s {ss.push(s)}
                   "}"                        -> [#send, #call,
                                                  [#func, [], [#begin].concat(ss)],
                                                  [#this]],
  semAction      = curlySemAction
                 | primExpr:r spaces          -> r
};

let BSSemActionTranslator = ometa(BSJSTranslator) {
};

let jsValue = function(type, value) {
  return [#Js, [type, value]];
};

let BSOMetaParser = ometa(BaseStrParser) {
  enum :r :d     = listOf(r, d):v ("," | empty) -> v,
  space          = ^space | fromTo('//', '\n') | fromTo('/*', '*/'),
  nameFirst      = '_' | '$' | letter,
  nameRest       = nameFirst | digit,
  tsName         = <nameFirst nameRest*>,
  name           = spaces tsName,
  hexDigit       = char:x {this.hexDigits.indexOf(x.toLowerCase())}:v
                                                             ?(v >= 0) -> v,
  eChar          = <'\\' ( 'u' hexDigit hexDigit hexDigit hexDigit
                         | 'x' hexDigit hexDigit
                         | char                                   )>:s -> unescape(s)
                 | char,
  tsString       = '\'' (~'\'' eChar)*:xs '\''                         -> xs.join(''),
  characters     = '`' '`' (~('\'' '\'') eChar)*:xs '\'' '\''          -> [#App, #seq,     jsValue(#string, xs.join(''))],
  sCharacters    = '"'     (~'"'         eChar)*:xs '"'                -> [#App, #token,   jsValue(#string, xs.join(''))],
  string         = (('#' | '`') tsName | tsString):xs                  -> [#App, #exactly, jsValue(#string, xs)],
  number         = <'-'? digit+>:n                                     -> [#App, #exactly, jsValue(#number, n)],
  keyword :xs    = token(xs) ~letterOrDigit                            -> xs,
  args           = '(' listOf(#hostExpr, ','):xs ")"                   -> xs
                 | empty                                               -> [],
  application    = "^"          name:rule args:as                      -> [#App, "super", jsValue(#string, rule)].concat(as)
                 | name:grm "." name:rule args:as                      -> [#App, "foreign",
                                                                           jsValue(#get, grm),
                                                                           jsValue(#string, rule)].concat(as)
                 |              name:rule args:as                      -> [#App, rule].concat(as),
  localsVars :s  =                                                        Locals.rename([this.locals, s]),
  hostExpr       = BSSemActionParser.expr:r localsVars(r):rr           -> [#Js, rr],
  curlyHostExpr  = BSSemActionParser.curlySemAction:r localsVars(r):rr -> [#Js, rr],
  primHostExpr   = BSSemActionParser.semAction:r localsVars(r):rr      -> [#Js, rr],
  atomicHostExpr = curlyHostExpr | primHostExpr,
  semAction      = curlyHostExpr:x
                 | "!"  atomicHostExpr:x,
  arrSemAction   = "->" atomicHostExpr:x,
  semPred        = "?"  atomicHostExpr:x                               -> [#Pred, x],
  expr           = expr5(true):x ("|"  expr5(true))+:xs                -> [#Or,  x].concat(xs)
                 | expr5(true):x ("||" expr5(true))+:xs                -> [#XOr, x].concat(xs)
                 | expr5(false),
  expr5 :ne      = interleavePart:x ("&&" interleavePart)+:xs          -> [#Interleave, x].concat(xs)
                 | expr4(ne),
  interleavePart = "(" expr4(true):part ")"                            -> ["1", part]
                 | expr4(true):part modedIPart(part),
  modedIPart     = [#And [#Many  :part]]                               -> ["*", part]
                 | [#And [#Many1 :part]]                               -> ["+", part]
                 | [#And [#Opt   :part]]                               -> ["?", part]
                 | :part                                               -> ["1", part],
  expr4 :ne      =                expr3*:xs arrSemAction:act           -> [#And].concat(xs).concat([act])
                 | ?ne            expr3+:xs                            -> [#And].concat(xs)
                 | ?(ne == false) expr3*:xs                            -> [#And].concat(xs),
  optIter :x     = '*'                                                 -> [#Many,  x]
                 | '+'                                                 -> [#Many1, x]
                 | '?'                                                 -> [#Opt,   x]
                 | empty                                               -> x,
  optBind :x     = ':' name:n                                          -> { this.locals[n] = true; [#Set, n, x] }
                 | empty                                               -> x,
  expr3          = ":" name:n                                          -> { this.locals[n] = true; [#Set, n, [#App, #anything]] }
                 | (expr2:x optIter(x) | semAction):e optBind(e)
                 | semPred,
  expr2          = "~" expr2:x                                         -> [#Not,       x]
                 | "&" expr1:x                                         -> [#Lookahead, x]
                 | expr1,
  expr1          = application
                 | ( keyword('undefined') | keyword('nil')
                   | keyword('true')      | keyword('false') ):x       -> [#App, #exactly, x]
                 | spaces (characters | sCharacters | string | number)
                 | "["  expr:x "]"                                     -> [#Form,      x]
                 | "<"  expr:x ">"                                     -> [#ConsBy,    x]
                 | "@<" expr:x ">"                                     -> [#IdxConsBy, x]
                 | "("  expr:x ")"                                     -> x,
  ruleName       = name
                 | spaces tsString,
  rule           = &(ruleName:n) !(this.locals = {})
                     rulePart(n):x ("," rulePart(n))*:xs               -> [#Rule, n, [#Or, x].concat(xs)],
  rulePart :rn   = ruleName:n ?(n == rn) expr4(false):b1 ( "=" expr:b2 -> [#And, b1, b2]
                                                         | empty       -> b1
                                                         ),
  grammar        = keyword('ometa') ( "(" name:sni ")" -> sni
                                    | empty -> 'OMeta' ):sn
  "{" enum(#rule, ','):rs "}"                                             BSOMetaOptimizer.optimizeGrammar(
                                                                            [#Grammar, sn].concat(rs)
                                                                          )
};
BSOMetaParser.hexDigits = "0123456789abcdef";

// By dispatching on the head of a list, the following idiom allows translators to avoid doing a linear search.
// (Note that the "=" in a rule definition is optional, so you can give your rules an "ML feel".)
let BSOMetaTranslator = ometa {
  App 'super' transFn+:args                -> [this.sName, '._superApplyWithArgs(this,', args.join(','), ')']            .join(''),
  App :rule   transFn*:args
    ( ?(this._optimizedCall(rule, args))   -> ['this.', this._callables[rule].name, '(', args.join(','), ')']            .join('')
    | ?(args.length < 1)                   -> ['this._apply("', rule, '")']                                              .join('')
    |                                      -> ['this._applyWithArgs("', rule, '",', args.join(','), ')']                 .join('') ),
  Pred       transFn:expr                  -> ['this._pred(', expr, ')']                                                 .join(''),
  Or         transFn*:xs                   -> ['this._or(',  xs.join(','), ')']                                          .join(''),
  XOr        transFn*:xs                       {xs.unshift(this.rName.toProgramString())}
                                           -> ['this._xor(', xs.join(','), ')']                                          .join(''),
  And        transFn+:xs                   -> xs.join(';'),
  And                                      -> 'undefined',
  Opt        transFn:x                     -> ['this._opt(',           x, ')']                                           .join(''),
  Many       transFn:x                     -> ['this._many(',          x, ')']                                           .join(''),
  Many1      transFn:x                     -> ['this._many1(',         x, ')']                                           .join(''),
  Set        :n transFn:v                    -> ['$vars.', n, '=', v]                                                      .join(''),
  Not        transFn:x                     -> ['this._not(',           x, ')']                                           .join(''),
  Lookahead  transFn:x                     -> ['this._lookahead(',     x, ')']                                           .join(''),
  Form       transFn:x                     -> ['this._form(',          x, ')']                                           .join(''),
  ConsBy     transFn:x                     -> ['this._consumedBy(',    x, ')']                                           .join(''),
  IdxConsBy  transFn:x                     -> ['this._idxConsumedBy(', x, ')']                                           .join(''),
  JumpTable  { this._storeVar++; }
             jtCase*:cases
             { this._storeVar--; }         -> this.jumpTableCode(cases),
  Interleave intPart*:xs                   -> ['this._interleave(', xs.join(','), ')']                                   .join(''),

  Function { this._storeVar++; }
           transFn:x
           { this._storeVar--; }           -> ['function(){', x, ';}']                                                   .join(''),
  FunctionStructure { this._storeVar++; }
           transFn+:xs
           { this._storeVar--; }           -> ['function(){var $r', this._storeVar + 1,
                                               '=this._startStructure(null);', xs.join(';'),
                                               ';return this._endStructure($r', this._storeVar + 1, ');}']               .join(''),
  ReturnStructure transFn:x                -> ['$r', this._storeVar, '.value=', x]                                       .join(''),
  Return          transFn:x                -> ['return ', x]                                                             .join(''),
  Parenthesis     transFn:x                -> ['(', x, ')']                                                              .join(''),
  Store           transFn:x                -> ['this._appendStructure($r', this._storeVar, ',', x, ')']                  .join(''),
  Js              transJs,

  Rule       :name {this.rName = name;
                    this._storeVar = 0; }
             trans:body                    -> ['\n"', name, '":function(){var $elf=this,',
                                               '$vars={},',
                                               '$r0=this._startStructure("', name, '");', body,
                                               ';return this._endStructure($r0);}']                                      .join(''),
  Grammar    :sName
             {this.sName = sName}
             trans*:rules                  -> ['objectThatDelegatesTo(', sName, ',{', rules.join(','), '})'].join(''),

  intPart  = [:mode transFn:part]          -> (mode.toProgramString()  + "," + part),
  jtCase   = [:x trans:e]                  -> [x.toProgramString(), e],

  transJs  = BSSemActionTranslator.trans,

  trans    = [:t apply(t):ans]             -> ans,
  transFn  = trans:x                       -> x
};
BSOMetaTranslator._callables = {
  anything: { name: "anything", nbArgs: 0, },
  apply:    { name: "_apply",   nbArgs: 1, },
  end:      { name: "end",      nbArgs: 0, },
  exactly:  { name: "exactly",  nbArgs: 1, },
  seq:      { name: "seq",      nbArgs: 1, },
};
BSOMetaTranslator._optimizedCall = function(rule, args) {
  let c = this._callables[rule];
  return c && c.nbArgs == args.length;
};
BSOMetaTranslator.jumpTableCode = function(cases) {
  var buf = new StringBuffer();
  buf.nextPutAll("(function(){var $r" + (this._storeVar + 1) + "=this._startStructure(null);")
  buf.nextPutAll("switch(this._appendStructure($r" + (this._storeVar + 1) + ",this._apply('anything'))){");
  for (var i = 0; i < cases.length; i += 1)
    buf.nextPutAll("case " + cases[i][0] + ":" + cases[i][1] + ";break;");
  buf.nextPutAll("default: throw fail}return this._endStructure($r" + (this._storeVar + 1) + ");}).call(this)");
  return buf.contents();
};
